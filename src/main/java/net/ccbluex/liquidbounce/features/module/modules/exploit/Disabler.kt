package net.ccbluex.liquidbounce.features.module.modules.exploit

import net.ccbluex.liquidbounce.LiquidBounce
import net.ccbluex.liquidbounce.event.*
import net.ccbluex.liquidbounce.features.module.Module
import net.ccbluex.liquidbounce.features.module.ModuleCategory
import net.ccbluex.liquidbounce.features.module.ModuleInfo
import net.ccbluex.liquidbounce.features.module.modules.combat.KillAura
import net.ccbluex.liquidbounce.features.module.modules.movement.Fly
import net.ccbluex.liquidbounce.features.module.modules.movement.Speed
import net.ccbluex.liquidbounce.ui.client.hud.element.elements.Notification
import net.ccbluex.liquidbounce.ui.client.hud.element.elements.NotificationType
import net.ccbluex.liquidbounce.ui.font.Fonts
import net.ccbluex.liquidbounce.utils.*
import net.ccbluex.liquidbounce.utils.misc.RandomUtils
import net.ccbluex.liquidbounce.utils.timer.MSTimer
import net.ccbluex.liquidbounce.value.BoolValue
import net.ccbluex.liquidbounce.value.IntegerValue
import net.ccbluex.liquidbounce.value.ListValue
import net.minecraft.client.gui.ScaledResolution
import net.minecraft.entity.player.PlayerCapabilities
import net.minecraft.init.Items
import net.minecraft.network.Packet
import net.minecraft.network.PacketBuffer
import net.minecraft.network.play.INetHandlerPlayServer
import net.minecraft.network.play.client.*
import net.minecraft.network.play.client.C03PacketPlayer.*
import net.minecraft.network.play.server.S02PacketChat
import net.minecraft.network.play.server.S08PacketPlayerPosLook
import net.minecraft.network.play.server.S3EPacketTeams
import net.minecraft.util.BlockPos
import net.minecraft.util.ResourceLocation
import net.minecraft.util.Vec3
import org.lwjgl.opengl.GL11.*
import scala.tools.nsc.transform.patmat.Logic.PropositionalLogic.Not
import java.awt.Color
import java.io.ByteArrayOutputStream
import java.io.DataOutputStream
import java.io.IOException
import java.util.*
import kotlin.math.round
import kotlin.math.sqrt

// lb+ reborn skid
@ModuleInfo(name = "Disabler", description = "Disable some anticheats' checks.", category = ModuleCategory.EXPLOIT)
class Disabler : Module() {

    val modeValue = ListValue(
        "Mode",
        arrayOf(
            "BlockDropCombat", // blockdrop combat disabler
            "MineplexCombat", // mineplex combat disabler
            "Hycraft", //As
            "Flying", // As
            "OldBlocksMC", // Dort
            "OldVerus", // Dort
            "LatestVerus", // FDP
            "PingSpoof", // ping spoof
            "Flag", // flag
            "Matrix", // re
            "Watchdog", // $100k anticheat
            "VanillaDesync" // Dort, again.
        ), "VanillaDesync"
    )

    // PingSpoof (idfk what's this purpose but i will keep it here.)
    private val minpsf: IntegerValue = object :
        IntegerValue("PingSpoof-MinDelay", 200, 0, 10000) {
        override fun onChanged(oldValue: Int, newValue: Int) {
            val v = maxpsf.get()
            if (v < newValue) set(v)
        }
    }
    private val maxpsf: IntegerValue = object :
        IntegerValue("PingSpoof-MaxDelay", 250, 0, 10000) {
        override fun onChanged(oldValue: Int, newValue: Int) {
            val v = minpsf.get()
            if (v > newValue) set(v)
        }
    }
    private val psfStartSendMode = ListValue(
        "PingSpoof-StartSendMode",
        arrayOf("All", "First"),
        "All")
    private val psfSendMode =
        ListValue("PingSpoof-SendMode", arrayOf("All", "First"),"All")
    private val psfWorldDelay =
        IntegerValue("PingSpoof-WorldDelay", 15000, 0, 30000)

    // flag
    private val flagMode =
        ListValue("Flag-Mode", arrayOf("Edit", "Packet"), "Edit")
    private val flagTick = IntegerValue("Flag-TickDelay", 25, 1, 200)
    private val flagSilent = BoolValue("Flag-SilentMode", false)

    // matrix
    private val matrixNoCheck = BoolValue("Matrix-NoModuleCheck", false)
    private val matrixMoveFix = BoolValue("Matrix-MoveFix", true)
    private val matrixMoveOnly = BoolValue("Matrix-MoveOnly", false)
    private val matrixNoMovePacket = BoolValue("Matrix-NoMovePacket", true)
    private val matrixHotbarChange = BoolValue("Matrix-HotbarChange", true)

    // verus
    private val verusLobbyValue = BoolValue(
        "LobbyCheck",
        true)
    private val verusFlagValue = BoolValue("Verus-Flag", true)
    private val verusSlientFlagApplyValue =
        BoolValue("Verus-SlientFlagApply", false)
    private val verusBufferSizeValue =
        IntegerValue("Verus-QueueActiveSize", 300, 0, 1000)
    private val verusPurseDelayValue =
        IntegerValue("Verus-PurseDelay", 490, 0, 2000)
    private val verusFlagDelayValue =
        IntegerValue("Verus-FlagDelay", 40, 40, 120)
    private val verusAntiFlyCheck = BoolValue("Verus-AntiFly", true)
    private val verusFakeInput = BoolValue("Verus-FakeInput", true)
    private val verusValidPos = BoolValue("Verus-ValidPosition", true)

    // watchdog
    val renderServer = BoolValue("Render-ServerSide", false)
    private val autoAlert = BoolValue("BanAlert", false)
    private val rotModify = BoolValue("RotationModifier", false)
    private val tifality90 =
        BoolValue("Tifality", false)
    private val noMoveKeepRot =
        BoolValue("NoMoveKeepRot", true)
    private val noC03s = BoolValue("NoC03s", true)
    private val testFeature = BoolValue("PingSpoof", true)
    private val testDelay =
        IntegerValue("Delay", 400, 0, 1000)
    private val checkValid =
        BoolValue("InvValidate", true)

    // debug
    private val debugValue = BoolValue("Debug", false)

    // sus
    private val susImage = ResourceLocation("liquidbounce+/sus.png")
    private var rotatingSpeed = 0F

    // variables
    private val keepAlives = arrayListOf<C00PacketKeepAlive>()
    private val transactions = arrayListOf<C0FPacketConfirmTransaction>()
    private val packetQueue = LinkedList<C0FPacketConfirmTransaction>()
    private val anotherQueue = LinkedList<C00PacketKeepAlive>()
    private val playerQueue = LinkedList<C03PacketPlayer>()

    private val packetBus = hashMapOf<Long, Packet<INetHandlerPlayServer>>()
    private val queueBus = LinkedList<Packet<INetHandlerPlayServer>>()

    private val msTimer = MSTimer()
    private val wdTimer = MSTimer()
    private val benTimer = MSTimer()

    private var alrSendY = false
    private var alrSprint = false

    private var expectedSetback = false

    private var sendDelay = 0
    private var shouldActive = false
    private var benHittingLean = false

    private var transCount = 0
    private var counter = 0
    private var randDelay = 250

    var shouldModifyRotation = false

    private var verusLastY = 0.0
    private var lastTick = 0

    private var s08count = 0
    private var ticking = 0
    private var lastYaw = 0F

    private var lastUid = 0

    private var initPos: Vec3? = null

    val speedTimer = MSTimer()

    val canModifyRotation: Boolean
        get() = (state && modeValue.get().equals("watchdog", true) && shouldModifyRotation)

    val canRenderInto3D: Boolean
        get() = (state && modeValue.get().equals("watchdog", true) && renderServer.get() && shouldModifyRotation)

    fun isMoving(): Boolean =
        (mc.thePlayer != null && (mc.thePlayer.movementInput.moveForward != 0F || mc.thePlayer.movementInput.moveStrafe != 0F || mc.thePlayer.movementInput.sneak || mc.thePlayer.movementInput.jump))

    fun debug(s: String, force: Boolean = false) {
        if (debugValue.get() || force)
            ClientUtils.displayChatMessage("§c>>§f $s")
    }

    fun shouldRun(): Boolean =
        mc.thePlayer != null && mc.thePlayer.inventory != null && (!verusLobbyValue.get() || !mc.thePlayer.inventory.hasItem(
            Items.compass
        )) && mc.thePlayer.ticksExisted > 5

    fun isInventory(action: Short): Boolean = action > 0 && action < 100

    override val tag: String
        get() = modeValue.get()

    override fun onEnable() {
        keepAlives.clear()
        transactions.clear()
        packetQueue.clear()
        anotherQueue.clear()
        playerQueue.clear()
        packetBus.clear()
        queueBus.clear()

        s08count = 0

        msTimer.reset()
        wdTimer.reset()
        benTimer.reset()
        expectedSetback = false
        shouldActive = false
        alrSendY = false
        alrSprint = false
        transCount = 0
        lastTick = 0
        ticking = 0

        lastUid = 0

        shouldModifyRotation = false
        benHittingLean = false

        rotatingSpeed = 0F
    }

    override fun onDisable() {
        keepAlives.forEach {
            PacketUtils.sendPacketNoEvent(it)
        }
        transactions.forEach {
            PacketUtils.sendPacketNoEvent(it)
        }

        keepAlives.clear()
        transactions.clear()
        packetQueue.clear()
        anotherQueue.clear()
        packetBus.clear()

        if (modeValue.get().equals("watchdog", true)) {
            anotherQueue.forEach { PacketUtils.sendPacketNoEvent(it) }
            packetQueue.forEach { PacketUtils.sendPacketNoEvent(it) }
        }

        if (modeValue.get().equals("pingspoof", true)) {
            // make sure not to cause weird flag
            for (p in queueBus)
                PacketUtils.sendPacketNoEvent(p)
        }
        queueBus.clear()

        msTimer.reset()

        mc.thePlayer.motionY = 0.0
        MovementUtils.strafe(0F)
        mc.timer.timerSpeed = 1F

        shouldModifyRotation = false
    }

    @EventTarget
    fun onWorld(event: WorldEvent) {
        transactions.clear()
        keepAlives.clear()
        packetQueue.clear()
        anotherQueue.clear()
        playerQueue.clear()
        packetBus.clear()
        queueBus.clear()

        s08count = 0

        msTimer.reset()
        wdTimer.reset()
        benTimer.reset()
        expectedSetback = false
        shouldActive = false
        alrSendY = false
        alrSprint = false
        benHittingLean = false
        transCount = 0
        counter = 0
        lastTick = 0
        ticking = 0
        lastUid = 0

        rotatingSpeed = 0F
    }

    @EventTarget
    fun onRender2D(event: Render2DEvent) {
        if (!shouldActive) {
            val sc = ScaledResolution(mc)

            if (modeValue.get().equals("pingspoof", true)) {
                if (!LiquidBounce.hud.notifications.contains(
                        Notification("${
                            (msTimer.hasTimeLeft(psfWorldDelay.get().toLong()).toFloat() / 1000F).toInt()
                        }s left...",NotificationType.NORMAL))) {
                    LiquidBounce.hud.addNotification(Notification("${
                        (msTimer.hasTimeLeft(psfWorldDelay.get().toLong()).toFloat() / 1000F).toInt()
                    }s left...",NotificationType.NORMAL))
                }
            }
            if ((modeValue.get().equals(
                    "watchdog",
                    true
                ) && testFeature.get()) && !ServerUtils.isHypixelLobby() && !mc.isSingleplayer
            ) {
                if (!LiquidBounce.hud.notifications.contains(Notification("Disabling watchdog...",NotificationType.NORMAL)))
                    LiquidBounce.hud.addNotification(Notification("Disabling watchdog...",NotificationType.NORMAL))
                if (!speedTimer.hasTimePassed(20000)) {
                    Fonts.font40.drawCenteredString("You can use speed after ${speedTimer.hasTimeLeft(20000) / 1000} s",
                        (ScaledResolution(mc).scaledWidth / 2).toFloat(),
                        (ScaledResolution(mc).scaledHeight / 2).toFloat(),Color.red.rgb,true)
                }
                if (!LiquidBounce.moduleManager.getModule("Speed")!!.state && speedTimer.hasTimePassed(20000)) {
                    LiquidBounce.moduleManager.getModule("Speed")!!.state = false
                    LiquidBounce.hud.addNotification(Notification("You cant use speed now! you can use speed after ${speedTimer.hasTimeLeft(20000) / 1000} s",NotificationType.BAD))
                }
            }
        }
    }

    @EventTarget
    fun onPacket(event: PacketEvent) {
        val packet = event.packet

        when (modeValue.get().lowercase(Locale.getDefault())) {

            "blockdropcombat" -> {
                if (packet is C00PacketKeepAlive && (keepAlives.size <= 0 || packet != keepAlives[keepAlives.size - 1])) {
                    debug("c00 added")
                    keepAlives.add(packet)
                    event.cancelEvent()
                }
                if (packet is C0FPacketConfirmTransaction && (transactions.size <= 0 || packet != transactions[transactions.size - 1])) {
                    debug("c0f added")
                    transactions.add(packet)
                    event.cancelEvent()
                }
            }

            "flying" -> {
                val packet = event.packet
                if (packet is C03PacketPlayer) {
                    val capabilities = PlayerCapabilities()
                    capabilities.disableDamage = false
                    capabilities.isFlying = true
                    capabilities.allowFlying = false
                    capabilities.isCreativeMode = false
                    mc.netHandler.addToSendQueue(C13PacketPlayerAbilities(capabilities))
                    debug("c13 added")
                }
            }

            "mineplexcombat" -> {
                val packet = event.packet
                if (packet is C00PacketKeepAlive) {
                    event.cancelEvent()
                    PacketUtils.sendPacketNoEvent(
                        C00PacketKeepAlive(
                            packet.key - RandomUtils.nextInt(
                                1000,
                                2147483647
                            )
                        )
                    )
                    debug("cancel c00")
                }
            }

            "latestverus" -> { // liulihaocai
                if (!shouldRun()) {
                    msTimer.reset()
                    packetQueue.clear()
                    return
                }

                if (packet is C0FPacketConfirmTransaction && !isInventory(packet.uid)) {
                    packetQueue.add(packet)
                    event.cancelEvent()
                    if (packetQueue.size > verusBufferSizeValue.get()) {
                        if (!shouldActive) {
                            shouldActive = true
                            LiquidBounce.hud.addNotification(
                                Notification(
                                    "Verus is go to sleep successful", NotificationType.GOOD
                                )
                            )
                        }
                        PacketUtils.sendPacketNoEvent(packetQueue.poll())
                    }
                    debug("c0f, ${packetQueue.size}")
                }

                if (packet is C0BPacketEntityAction) {
                    event.cancelEvent()
                    debug("ignored packet action")
                }

                if (packet is C03PacketPlayer) {
                    if (verusFlagValue.get() && mc.thePlayer.ticksExisted % verusFlagDelayValue.get() == 0) {
                        debug("modified c03")
                        packet.y -= 11.015625 // just phase into ground instead (minimum to flag)
                        packet.onGround = false
                        packet.isMoving = false
                    }
                    if (verusValidPos.get() && packet is C03PacketPlayer) {
                        if (packet.y % 0.015625 == 0.0) {
                            packet.onGround = true
                            debug("true asf")
                        }
                    }
                }

                if (packet is S08PacketPlayerPosLook && verusSlientFlagApplyValue.get()) {
                    val x = packet.x - mc.thePlayer.posX
                    val y = packet.y - mc.thePlayer.posY
                    val z = packet.z - mc.thePlayer.posZ
                    val diff = sqrt(x * x + y * y + z * z)
                    if (diff <= 8) {
                        event.cancelEvent()
                        // verus, why
                        debug("flag silent accept")
                        PacketUtils.sendPacketNoEvent(
                            C06PacketPlayerPosLook(
                                packet.x,
                                packet.y,
                                packet.z,
                                packet.getYaw(),
                                packet.getPitch(),
                                false
                            )
                        )
                    }
                }
            }

            "oldverus" -> {
                if (packet is C03PacketPlayer) {
                    val yPos = round(mc.thePlayer.posY / 0.015625) * 0.015625
                    mc.thePlayer.setPosition(mc.thePlayer.posX, yPos, mc.thePlayer.posZ)

                    if (mc.thePlayer.ticksExisted % 45 == 0) {
                        debug("flag")
                        PacketUtils.sendPacketNoEvent(
                            C04PacketPlayerPosition(
                                mc.thePlayer.posX,
                                mc.thePlayer.posY,
                                mc.thePlayer.posZ,
                                true
                            )
                        )
                        PacketUtils.sendPacketNoEvent(
                            C04PacketPlayerPosition(
                                mc.thePlayer.posX,
                                mc.thePlayer.posY - 11.725,
                                mc.thePlayer.posZ,
                                false
                            )
                        )
                        PacketUtils.sendPacketNoEvent(
                            C04PacketPlayerPosition(
                                mc.thePlayer.posX,
                                mc.thePlayer.posY,
                                mc.thePlayer.posZ,
                                true
                            )
                        )
                    }
                }

                if (packet is S08PacketPlayerPosLook) {
                    if (mc.thePlayer == null || mc.thePlayer.ticksExisted <= 0) return

                    var x = packet.getX() - mc.thePlayer.posX
                    var y = packet.getY() - mc.thePlayer.posY
                    var z = packet.getZ() - mc.thePlayer.posZ
                    var diff = sqrt(x * x + y * y + z * z)
                    if (diff <= 8) {
                        event.cancelEvent()
                        PacketUtils.sendPacketNoEvent(
                            C06PacketPlayerPosLook(
                                packet.getX(),
                                packet.getY(),
                                packet.getZ(),
                                packet.getYaw(),
                                packet.getPitch(),
                                true
                            )
                        )

                        debug("silent s08 accept")
                    }
                }

                if (packet is C0FPacketConfirmTransaction && !isInventory(packet.uid)) {
                    repeat(4) {
                        packetQueue.add(packet)
                    }
                    event.cancelEvent()
                    debug("c0f dupe: 4x")
                }
            }

            "oldblocksmc" -> {
                if (!shouldRun()) {
                    queueBus.clear()
                    return
                }

                if (packet is C0BPacketEntityAction) {
                    event.cancelEvent()
                    debug("cancel action")
                }

                if (packet is S08PacketPlayerPosLook) {
                    if (mc.thePlayer.getDistance(packet.x, packet.y, packet.z) < 8) {
                        PacketUtils.sendPacketNoEvent(
                            C06PacketPlayerPosLook(
                                packet.x,
                                packet.y,
                                packet.z,
                                packet.yaw,
                                packet.pitch,
                                false
                            )
                        )
                        event.cancelEvent()
                        debug("silent flag")
                    }
                }

                if (packet is C00PacketKeepAlive || (packet is C0FPacketConfirmTransaction && !isInventory(packet.uid))) {
                    queueBus.add(packet as Packet<INetHandlerPlayServer>)
                    event.cancelEvent()

                    debug("c0f or c00, ${queueBus.size}")

                    if (queueBus.size > 300) {
                        PacketUtils.sendPacketNoEvent(queueBus.poll())
                        debug("poll")
                    }
                }

                if (packet is C03PacketPlayer) {
                    if (mc.thePlayer.ticksExisted % 20 == 0) {
                        PacketUtils.sendPacketNoEvent(C0CPacketInput(0.98f, 0.98f, false, false))
                        debug("c18 and c0c")
                    }

                    if (mc.thePlayer.ticksExisted % 45 == 0) {
                        packet.y = -0.015625
                        packet.onGround = false
                        packet.isMoving = false
                        debug("flag packet")
                    }
                }
            }

            "flag" -> {
                if (packet is C03PacketPlayer && flagMode.get().equals(
                        "edit",
                        true
                    ) && mc.thePlayer.ticksExisted > 0 && mc.thePlayer.ticksExisted % flagTick.get() == 0
                ) {
                    packet.isMoving = false
                    packet.onGround = false
                    packet.y = -0.08

                    debug("flagged")
                }
                if (packet is S08PacketPlayerPosLook && flagSilent.get()) {
                    if (mc.thePlayer == null || mc.thePlayer.ticksExisted <= 0) return

                    var x = packet.getX() - mc.thePlayer.posX
                    var y = packet.getY() - mc.thePlayer.posY
                    var z = packet.getZ() - mc.thePlayer.posZ
                    var diff = sqrt(x * x + y * y + z * z)
                    if (diff <= 8) {
                        event.cancelEvent()
                        PacketUtils.sendPacketNoEvent(
                            C06PacketPlayerPosLook(
                                packet.getX(),
                                packet.getY(),
                                packet.getZ(),
                                packet.getYaw(),
                                packet.getPitch(),
                                true
                            )
                        )

                        debug("silent s08 accept")
                    }
                }
            }

            "pingspoof" -> {
                if (packet is C0FPacketConfirmTransaction && !isInventory(packet.uid)) {
                    queueBus.add(packet)
                    event.cancelEvent()

                    debug("c0f added, action id ${packet.uid}, target id ${packet.windowId}")
                }
                if (packet is C00PacketKeepAlive) {
                    queueBus.add(packet)
                    event.cancelEvent()

                    debug("c00 added, key ${packet.key}")
                }
            }

            "matrix" -> {
                if (matrixNoCheck.get() || LiquidBounce.moduleManager.getModule(Speed::class.java)!!.state || LiquidBounce.moduleManager.getModule(
                        Fly::class.java
                    )!!.state
                ) {
                    if (packet is C03PacketPlayer) {
                        if (matrixNoMovePacket.get() && !packet.isMoving) {
                            event.cancelEvent()
                            debug("no move, cancelled")
                            return
                        }
                        if (matrixMoveFix.get()) {
                            // almost completely disable strafe check, nofall
                            packet.onGround = true
                            if (!packet.rotating) { // fix fly sometimes doesn't land properly since most mc servers all refer to C04, C05, C06 as C03s aka. PacketPlayerInFlying.
                                packet.rotating = true
                                packet.yaw = mc.thePlayer.rotationYaw
                                packet.pitch = mc.thePlayer.rotationPitch
                            }
                        }
                    }
                }
            }

            "watchdog" -> {
                if (mc.isSingleplayer) return

                if (autoAlert.get() && packet is S02PacketChat && packet.chatComponent.unformattedText
                        .contains("Cages opened!", true)
                )
                    speedTimer.reset()
                    LiquidBounce.hud.addNotification(
                        Notification(
                            "Speed is bannable before game started 20 seconds.",
                            NotificationType.WARNING

                        )
                    )

                if (testFeature.get() && !ServerUtils.isHypixelLobby()) {
                    if (packet is C0FPacketConfirmTransaction && (!checkValid.get() || !isInventory(packet.uid))) {
                        event.cancelEvent()
                        packetQueue.add(packet)

                        debug("c0f, ${packet.uid} ID, ${packet.windowId} wID")

                        if (!shouldActive) {
                            shouldActive = true
                            debug("activated")
                            LiquidBounce.hud.addNotification(Notification("Watchdog get disabled!",NotificationType.GOOD))
                        }
                    }
                    if (packet is C00PacketKeepAlive) {
                        event.cancelEvent()
                        anotherQueue.add(packet)

                        wdTimer.reset()
                        debug("c00, ${packet.key}")
                    }
                    if (packet is C03PacketPlayer || packet is C0BPacketEntityAction || packet is C08PacketPlayerBlockPlacement || packet is C0APacketAnimation) {
                        if (!shouldActive)
                            event.cancelEvent()
                    }
                    if (packet is S08PacketPlayerPosLook && !shouldActive) {
                        if (alrSendY) {
                            //mc.netHandler.addToSendQueue(C06PacketPlayerPosLook(packet.getX(), packet.getY(), packet.getZ(), packet.getYaw(), packet.getPitch(), false))
                            event.cancelEvent()
                            debug("no s08")
                        } else {
                            alrSendY = true
                            debug("first s08, ignore")
                        }
                    }
                }

                if (noC03s.get() && packet is C03PacketPlayer)
                    if (packet !is C04PacketPlayerPosition && packet !is C05PacketPlayerLook && packet !is C06PacketPlayerPosLook)
                        event.cancelEvent()
            }

            "hycraft" -> {
                if (packet is S3EPacketTeams) {
                    debug("S3E Teams Cancelled")
                    event.cancelEvent()
                }
                if (packet is S08PacketPlayerPosLook) {
                    val x = packet.x
                    val y = packet.y
                    val z = packet.z

                    if (x >= 200000 || x <= -200000 ||
                        y >= 200000 || y <= -200000 ||
                        z >= 200000 || z <= -200000
                    ) {
                        mc.netHandler.networkManager.sendPacket(
                            C03PacketPlayer.C06PacketPlayerPosLook(
                                x,
                                y,
                                z,
                                packet.getYaw(),
                                packet.getPitch(),
                                false
                            )
                        )
                        debug("Invalid S08 TP")
                        event.cancelEvent()
                    }
                }
            }
        }
    }

    fun flush(check: Boolean) {
        if ((if (check) psfSendMode.get() else psfStartSendMode.get()).equals("all", true))
            while (queueBus.size > 0) {
                PacketUtils.sendPacketNoEvent(queueBus.poll())
            }
        else
            PacketUtils.sendPacketNoEvent(queueBus.poll())
    }

    @EventTarget()
    fun onMotion(event: MotionEvent) {
        val speed = LiquidBounce.moduleManager.getModule(Speed::class.java)!!
        val fly = LiquidBounce.moduleManager.getModule(Fly::class.java)!!

        if (event.eventState == EventState.PRE)
            shouldModifyRotation = false

        if (modeValue.get().equals("watchdog", true)) {
            if (event.eventState == EventState.PRE) {
                if ((speed.state || fly.state) && rotModify.get()) {
                    shouldModifyRotation = true
                }
                if (mc.isSingleplayer) return
                if (testFeature.get() && !ServerUtils.isHypixelLobby()) {
                    if (shouldActive && wdTimer.hasTimePassed(testDelay.get().toLong())) {
                        while (!anotherQueue.isEmpty()) {
                            PacketUtils.sendPacketNoEvent(anotherQueue.poll())
                            debug("c00, ${anotherQueue.size}")
                        }
                        while (!packetQueue.isEmpty()) {
                            PacketUtils.sendPacketNoEvent(packetQueue.poll())
                            debug("c0f, ${packetQueue.size}")
                        }
                    }
                }
            }
        }

        if (event.eventState == EventState.POST && (!matrixMoveOnly.get() || isMoving())) // check post event
            if (modeValue.get().equals("matrix", true)) {
                if (matrixNoCheck.get() || LiquidBounce.moduleManager.getModule(Fly::class.java)!!.state || LiquidBounce.moduleManager.getModule(
                        Speed::class.java
                    )!!.state
                ) {
                    var changed = false
                    if (matrixHotbarChange.get()) for (i in 0..8) {
                        // find a empty inventory slot
                        if (mc.thePlayer.inventory.mainInventory[i] == null && i != mc.thePlayer.inventory.currentItem) {
                            PacketUtils.sendPacketNoEvent(C09PacketHeldItemChange(i))
                            changed = true
                            debug("found empty slot $i, switching")
                            break
                        }
                    }

                    PacketUtils.sendPacketNoEvent(
                        C06PacketPlayerPosLook(
                            mc.thePlayer.posX,
                            mc.thePlayer.posY,
                            mc.thePlayer.posZ,
                            RotationUtils.serverRotation.yaw,
                            RotationUtils.serverRotation.pitch,
                            mc.thePlayer.onGround
                        )
                    )
                    mc.netHandler.addToSendQueue(
                        C08PacketPlayerBlockPlacement(
                            BlockPos(-1, -1, -1),
                            -1,
                            null,
                            0f,
                            0f,
                            0f
                        )
                    )
                    debug("sent placement")

                    if (changed) {
                        PacketUtils.sendPacketNoEvent(C09PacketHeldItemChange(mc.thePlayer.inventory.currentItem))
                        debug("switched back")
                    }
                }
            }
    }

    @EventTarget
    fun onUpdate(event: UpdateEvent) {
        when (modeValue.get().lowercase(Locale.getDefault())) {
            "blockdropcombat" -> {
                if (msTimer.hasTimePassed(3000L) && keepAlives.size > 0 && transactions.size > 0) {
                    PacketUtils.sendPacketNoEvent(keepAlives[keepAlives.size - 1])
                    PacketUtils.sendPacketNoEvent(transactions[transactions.size - 1])

                    debug("c00 no.${keepAlives.size - 1} sent.")
                    debug("c0f no.${transactions.size - 1} sent.")
                    keepAlives.clear()
                    transactions.clear()
                    msTimer.reset()
                }
            }

            "oldverus" -> {
                if (mc.thePlayer.ticksExisted % 180 == 0) {
                    while (packetQueue.size > 22) {
                        PacketUtils.sendPacketNoEvent(packetQueue.poll())
                    }
                    debug("pushed queue until size < 22.")
                }
            }

            "latestverus" -> {
                if (verusAntiFlyCheck.get() && !shouldActive) {
                    val flyMod = LiquidBounce.moduleManager[Fly::class.java]!!
                    if (flyMod.state) {
                        flyMod.state = false
                        LiquidBounce.hud.addNotification(
                            Notification(
                                "You can't fly before verus go to sleep.",
                                NotificationType.WARNING
                            )
                        )
                        debug("no fly allowed")
                    }
                }
                if (mc.thePlayer.ticksExisted % 15 == 0 && shouldRun()) {
                    if (verusFakeInput.get()) {
                        mc.netHandler.addToSendQueue(
                            C0CPacketInput(
                                mc.thePlayer.moveStrafing.coerceAtMost(0.98F),
                                mc.thePlayer.moveForward.coerceAtMost(0.98F),
                                mc.thePlayer.movementInput.jump,
                                mc.thePlayer.movementInput.sneak
                            )
                        )
                        debug("c0c")
                    }
                }
            }

            "pingspoof" -> {
                if (msTimer.hasTimePassed(psfWorldDelay.get().toLong()) && !shouldActive) {
                    shouldActive = true
                    sendDelay = RandomUtils.nextInt(minpsf.get(), maxpsf.get())
                    if (queueBus.size > 0) flush(false)
                    msTimer.reset()
                    debug("activated. expected next delay: ${sendDelay}ms")
                }

                if (shouldActive) {
                    if (msTimer.hasTimePassed(sendDelay.toLong()) && !queueBus.isEmpty()) {
                        flush(true)
                        sendDelay = RandomUtils.nextInt(minpsf.get(), maxpsf.get())
                        msTimer.reset()
                        debug("expected next delay: ${sendDelay}ms")
                    }
                }
            }

            "flag" -> {
                if (flagMode.get().equals(
                        "packet",
                        true
                    ) && mc.thePlayer.ticksExisted > 0 && mc.thePlayer.ticksExisted % flagTick.get() == 0
                ) {
                    PacketUtils.sendPacketNoEvent(
                        C04PacketPlayerPosition(
                            mc.thePlayer.posX,
                            -0.08,
                            mc.thePlayer.posZ,
                            mc.thePlayer.onGround
                        )
                    )
                    debug("flagged")
                }
            }
        }
    }
}